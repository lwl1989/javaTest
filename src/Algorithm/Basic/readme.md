## 堆排序

#### 二叉树

> 堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。

二叉树分类

- 全二叉树（Complete Binary Tree）： 除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐。
- 满二叉树（Full Binary Tree）：除了叶子结点之外的每一个结点都有两个孩子，每一层(当然包含最后一层)都被完全填充。
- 完满二叉树(Perfect Binary Tree)：除了叶子结点之外的每一个结点都有两个孩子结点。


这里需要纠正一点：

满二叉树和完满二叉树在国内翻译反了，完满二叉树又称为完美二叉树。

完美二叉树

![](https://raw.githubusercontent.com/lwl1989/javaTest/master/static/完美二叉树.png)

满二叉树

![](https://raw.githubusercontent.com/lwl1989/javaTest/master/static/满二叉树.png)

完全二叉树

![](https://raw.githubusercontent.com/lwl1989/javaTest/master/static/完全二叉树.png)

### 完全二叉树特性和特点

> 完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。

##### 性质

1. 具有n个节点的完全二叉树的深度为 k=log2n, n > 2^(k-1)-1

2.【满二叉树】i层的节点数目为：2i

3.【满二叉树】节点总数和深度的关系：n=∑k(i=0)2^i = 2^(k+1)−1

4.【完全二叉树】最后一层的节点数为：n−(2k−1)=n+1−2k （因为除最后一层外，为【满二叉树】）

5.【完全二叉树】左子树的节点数为（总节点为n）：

    l(n) = n-2^(k-1), n+1 - 2^k <= 2^(k-1)
    //因为最后一层全都在左子树，右子树为 满的二叉树 高度为 k-2

    l(n) = 2^k-1,   n+1 - 2^k > 2^(k-1)
    //因为左子树为满二叉树，高度为k-1

6.【完全二叉树】右子树： r(n)=n−l(n)

7.【完全二叉树】子节点 = (父节点 - 1 ） / 2

8.【完全二叉树】父节点 = 子节点 * 2 + 1

......


### 堆排序


最小堆 最小堆任何一个父节点的值，都小于等于它左右孩子节点的值。

最大堆 最大堆任何一个父节点的值，都大于等于它左右孩子节点的值。

整体思想，元素之需要和他的父亲元素进行比较，假如大于/小于父亲元素，则再次对比父亲的元素的父亲，以此类推。因此，比较的最大次数相当于二叉树的深度。


```
      5            5>2 && 2<3 && 2<5  => index变成2的index
    3    2                     比较节点的位置放入2  节点位置改为2的节点位置 并寻找是否有下一个子节点
       6   4       5>3 && 4<6 && 4<5
                               比较节点的位置放入4  节点位置改为4的节点位置 并寻找是否有下一个子节点
    假如孩子节点有右节点 并且 右节点小于左节点  节点转移到右节点位置
```


如图（有点乱）

![](https://raw.githubusercontent.com/lwl1989/javaTest/master/static/排序过程.png)

如果有右子树一定先和右子树进行比较

如果没有右子树则和双亲进行比较

看一张别人的大顶堆排序图：

![](https://raw.githubusercontent.com/lwl1989/javaTest/master/static/别人的大顶堆排序图.png)


[本文代码位置](https://github.com/lwl1989/javaTest/blob/master/src/Self/Heap.java)


## 背包问题(动态规划算法)

定义： 给定n种物品和一个容量(c)固定的背包，物品i的重量是wi，价格为vi。求如何装入物品，使背包物品总价值最大。

### 思路

根据动态规划解题步骤（问题抽象化、建立模型、寻找约束条件、判断是否满足最优性原理、找大问题与小问题的递推关系式、填表、寻找解组成）找出01背包问题的最优解以及解组成，然后编写代码实现。

>  最优性原理是动态规划的基础，最优性原理是指“多阶段决策过程的最优决策序列具有这样的性质：不论初始状态和初始决策如何，对于前面决策所造成的某一状态而言，其后各阶段的决策序列必须构成最优策略”。


1. 定义存储数组 m[n][c], m[i][j]表示在面对第i件物品时，且背包容量为j时所能获得的最大价值。

2. j < w[i],这时候，剩余重量不足以放下当前物品，跳过

3. j > w[i], 对比当前可拿物品中价值比最高的物品

4. 直至无法拿取重量最小的物品或者剩余空间为0


伪代码：
```
if(j>w[i]) {
    m[i][j] = max(m[i-1][j], [i-1][j-w[i]] + v[i]);
}else{
    m[i][j] = m[i-1][j]
}
```